<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>markdown的数学公式语法</title>
      <link href="/posts/12263/"/>
      <url>/posts/12263/</url>
      
        <content type="html"><![CDATA[<h2 id="行内与独行"><a href="#行内与独行" class="headerlink" title="行内与独行"></a>行内与独行</h2><ul><li><code>行内公式:</code> 将公式插入到本行内，符号: <code>$公式内容$</code></li><li><code>独行公式:</code> 将公式插入到新的一行内，并且居中，符号:<code>$$公式内容$$</code></li></ul><h2 id="上标、下标与组合"><a href="#上标、下标与组合" class="headerlink" title="上标、下标与组合"></a>上标、下标与组合</h2><ul><li>上标符号，符号：<code>^</code>，如：$x^4$</li><li>下标符号，符号：<code>_</code>，如：$x_1$</li><li>组合符号，符号：<code>{}</code>，如：${16}<em>{8}O{2+}</em>{2}$</li></ul><h2 id="汉字、字体与格式"><a href="#汉字、字体与格式" class="headerlink" title="汉字、字体与格式"></a>汉字、字体与格式</h2><ul><li>汉字形式，符号：<code>\mbox{}</code>，如：$V_{\mbox{初始}}$</li><li>字体控制，符号：<code>\displaystyle</code>，如：$\displaystyle \frac{x+y}{y+z}$</li><li>下划线符号，符号：<code>\underline</code>，如：$\underline{x+y}$</li><li>标签，符号\tag{数字}，如：$\tag{11}$</li><li>上大括号，符号：<code>\overbrace{算式}</code>，如：$\overbrace{a+b+c+d}^{2.0}$</li><li>下大括号，符号：<code>\underbrace{算式}</code>，如：$a+\underbrace{b+c}_{1.0}+d$</li><li>上位符号，符号：<code>\stacrel{上位符号}{基位符号}</code>，如：$\vec{x}\stackrel{\mathrm{def}}{=}{x_1,\dots,x_n}$</li></ul><h2 id="占位符"><a href="#占位符" class="headerlink" title="占位符"></a>占位符</h2><ul><li>两个空格，符号：<code>\qquad</code>，如：$x \qquad y$</li><li>空格，符号：<code>\quad</code>，如：$x \quad y$</li><li>大空格，符号<code>\</code>，如：$x \ y$</li><li>中空格，符号<code>:</code>，如：$x : y$</li><li>小空格，符号<code>,</code>，如：$x , y$</li><li>没有空格,如：$xy$</li><li>紧贴，符号<code>!</code>,如：$x ! y$</li></ul><h2 id="定界符与组合"><a href="#定界符与组合" class="headerlink" title="定界符与组合"></a>定界符与组合</h2><ul><li>括号，符号:<code>\big(\big)</code> <code>\Big(\Big)</code> <code>\bigg(\bigg)</code> <code>\Bigg(\Bigg)</code>.</li><li>中括号，符号：[]，如：$[x+y]$</li><li>大括号，符号：<code>{}</code>，如：${x+y}$</li><li>自适应括号，符号：<code>\left</code> <code>\right</code>，如：$\left(x\right)$，$\left(x{yz}\right)$</li><li>组合公式，符号：<code>{上位公式 \choose 下位公式}</code>，如：${n+1 \choose k}={n \choose k}+{n \choose k-1}$</li><li>组合公式，符号：<code>{上位公式 \atop 下位公式}</code>，如：$\sum_{k_0,k_1,\ldots&gt;0 \atop k_0+k_1+\cdots=n}A_{k_0}A_{k_1}\cdots$</li></ul><h2 id="四则运算"><a href="#四则运算" class="headerlink" title="四则运算"></a>四则运算</h2><ul><li>加法运算，符号：<code>+</code>，如：$x+y=z$</li><li>减法运算，符号：<code>-</code>，如：$x-y=z$</li><li>加减运算，符号：<code>\pm</code>，如：$x \pm y=z$</li><li>减甲运算，符号：<code>\mp</code>，如：$x \mp y=z$</li><li>乘法运算，符号：<code>\times</code>，如：$x \times y=z$</li><li>点乘运算，符号：<code>\cdot</code>，如：$x \cdot y=z$</li><li>星乘运算，符号：<code>\ast</code>，如：$x \ast y=z$</li><li>除法运算，符号：<code>\div</code>，如：$x \div y=z$</li><li>斜法运算，符号：<code>/</code>，如：$x/y=z$</li><li>分式表示，符号：<code>\frac{分子}{分母}</code>，如：$\frac{x+y}{y+z}$</li><li>分式表示，符号：<code>{分子} \voer {分母}</code>，如：${x+y} \over {y+z}$</li><li>绝对值表示，符号：<code>||</code>，如：$|x+y|$</li></ul><h2 id="高级运算"><a href="#高级运算" class="headerlink" title="高级运算"></a>高级运算</h2><ul><li>平均数运算，符号：\overline{算式}，如：$\overline{xyz}$</li><li>开二次方运算，符号：\sqrt，如：$\sqrt x$</li><li>开方运算，符号：<code>\sqrt[开方数]{被开方数}</code>，如：$\sqrt[3]{x+y}$</li><li>对数运算，符号：<code>\log</code>，如：$\log(x)$</li><li>极限运算，符号：<code>\lim</code>，如：$\lim^{x \to \infty}_{y \to 0}{\frac{x}{y}}$</li><li>极限运算，符号：<code>\displaystyle \lim</code>，如：$\displaystyle \lim^{x \to \infty}_{y \to 0}{\frac{x}{y}}$</li><li>求和运算，符号：<code>\sum</code>，如：$\sum^{x \to \infty}_{y \to 0}{\frac{x}{y}}$</li><li>求和运算，符号：<code>\displaystyle \sum</code>，如：$\displaystyle \sum^{x \to \infty}_{y \to 0}{\frac{x}{y}}$</li><li>积分运算，符号：<code>\int</code>，如：$\int^{\infty}_{0}{xdx}$</li><li>积分运算，符号：<code>\displaystyle \int</code>，如：$\displaystyle \int^{\infty}_{0}{xdx}$</li><li>微分运算，符号：<code>\partial</code>，如：$\frac{\partial x}{\partial y}$</li><li>矩阵表示，符号：<code>\begin{matrix} \end{matrix}</code>，如：$\left[\begin{matrix} 1 &amp;2 &amp;\cdots &amp;4\5 &amp;6 &amp;\cdots &amp;8\vdots &amp;\vdots &amp;\ddots&amp;\vdots\13 &amp;14 &amp;\cdots &amp;16\end{matrix} \right]$    </li></ul><h2 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h2><ul><li>等于运算，符号：<code>=</code>，如：$x+y=z$</li><li>大于运算，符号：<code>&gt;</code>，如：$x+y&gt;z$</li><li>小于运算，符号：<code>&lt;</code>，如：$x+y&lt;z$</li><li>大于等于运算，符号：<code>\geq</code>，如：$x+y \geq z$</li><li>小于等于运算，符号：<code>\leq</code>，如：$x+y \leq z$</li><li>不等于运算，符号：<code>\neq</code>，如：$x+y \neq z$</li><li>不大于等于运算，符号：<code>\ngeq</code>，如：$x+y \ngeq z$</li><li>不大于等于运算，符号：<code>\not\geq</code>，如：$x+y \not\geq z$</li><li>不小于等于运算，符号：<code>\nleq</code>，如：$x+y \nleq z$</li><li>不小于等于运算，符号：<code>\not\leq</code>，如：$x+y \not\leq z$</li><li>约等于运算，符号：<code>\approx</code>，如：$x+y \approx z$</li><li>恒定等于运算，符号：<code>\equiv</code>，如：$x+y \equiv z$</li></ul><h2 id="集合运算"><a href="#集合运算" class="headerlink" title="集合运算"></a>集合运算</h2><ul><li>属于运算，符号：<code>\in</code>，如：$x \in y$</li><li>不属于运算，符号：<code>\notin</code>，如：$x \notin y$</li><li>不属于运算，符号：<code>\not\in</code>，如：$x \not\in y$</li><li>子集运算，符号：<code>\subset</code>，如：$x \subset y$</li><li>子集运算，符号：<code>\supset</code>，如：$x \supset y$</li><li>真子集运算，符号：<code>\subseteq</code>，如：$x \subseteq y$</li><li>非真子集运算，符号：<code>\subsetneq</code>，如：$x \subsetneq y$</li><li>真子集运算，符号：<code>\supseteq</code>，如：$x \supseteq y$</li><li>非真子集运算，符号：<code>\supsetneq</code>，如：$x \supsetneq y$</li><li>非子集运算，符号：<code>\not\subset</code>，如：$x \not\subset y$</li><li>非子集运算，符号：<code>\not\supset</code>，如：$x \not\supset y$</li><li>并集运算，符号：<code>\cup</code>，如：$x \cup y$</li><li>交集运算，符号：<code>\cap</code>，如：$x \cap y$</li><li>差集运算，符号：<code>\setminus</code>，如：$x \setminus y$</li><li>同或运算，符号：<code>\bigodot</code>，如：$x \bigodot y$</li><li>同与运算，符号：<code>\bigotimes</code>，如：$x \bigotimes y$</li><li>实数集合，符号：<code>\mathbb{R}</code>，如：\mathbb{R}</li><li>自然数集合，符号：<code>\mathbb{Z}</code>，如：\mathbb{Z}</li><li>空集，符号：<code>\emptyset</code>，如：$\emptyset$</li></ul><h2 id="数学符号"><a href="#数学符号" class="headerlink" title="数学符号"></a>数学符号</h2><ul><li>无穷，符号：<code>\infty</code>，如：$\infty$</li><li>虚数，符号：<code>\imath</code>，如：$\imath$</li><li>虚数，符号：<code>\jmath</code>，如：$\jmath$</li><li>数学符号，符号<code>\hat{a}</code>，如：$\hat{a}$</li><li>数学符号，符号<code>\check{a}</code>，如：$\check{a}$</li><li>数学符号，符号<code>\breve{a}</code>，如：$\breve{a}$</li><li>数学符号，符号<code>\tilde{a}</code>，如：$\tilde{a}$</li><li>数学符号，符号<code>\bar{a}</code>，如：$\bar{a}$</li><li>矢量符号，符号<code>\vec{a}</code>，如：$\vec{a}$</li><li>数学符号，符号<code>\acute{a}</code>，如：$\acute{a}$</li><li>数学符号，符号<code>\grave{a}</code>，如：$\grave{a}$</li><li>数学符号，符号<code>\mathring{a}</code>，如：$\mathring{a}$</li><li>一阶导数符号，符号<code>\dot{a}</code>，如：$\dot{a}$</li><li>二阶导数符号，符号<code>\ddot{a}</code>，如：$\ddot{a}$</li><li>上箭头，符号：<code>\uparrow</code>，如：$\uparrow$</li><li>上箭头，符号：<code>\Uparrow</code>，如：$\Uparrow$</li><li>下箭头，符号：<code>\downarrow</code>，如：$\downarrow$</li><li>下箭头，符号：<code>\Downarrow</code>，如：$\Downarrow$</li><li>左箭头，符号：<code>\leftarrow</code>，如：$\leftarrow$</li><li>左箭头，符号：<code>\Leftarrow</code>，如：$\Leftarrow$</li><li>右箭头，符号：<code>\rightarrow</code>，如：$\rightarrow$</li><li>右箭头，符号：<code>\Rightarrow</code>，如：$\Rightarrow$</li><li>底端对齐的省略号，符号：<code>\ldots</code>，如：$1,2,\ldots,n$</li><li>中线对齐的省略号，符号：<code>\cdots</code>，如：$x_1^2 + x_2^2 + \cdots + x_n^2$</li><li>竖直对齐的省略号，符号：<code>\vdots</code>，如：$\vdots$</li><li>斜对齐的省略号，符号：<code>\ddots</code>，如：$\ddots$</li></ul><h2 id="希腊字母"><a href="#希腊字母" class="headerlink" title="希腊字母"></a>希腊字母</h2><table><thead><tr><th align="left">字母</th><th>实现</th><th>字母</th><th>实现</th><th>字母</th><th>实现</th><th>字母</th><th align="right">实现</th></tr></thead><tbody><tr><td align="left">A</td><td>A</td><td>α</td><td>\alhpa</td><td>B</td><td>B</td><td>β</td><td align="right">\beta</td></tr><tr><td align="left">Γ</td><td>\Gamma</td><td>γ</td><td>\gamma</td><td>Δ</td><td>\Delta</td><td>δ</td><td align="right">\delta</td></tr><tr><td align="left">E</td><td>E</td><td>ϵ</td><td>\epsilon</td><td>Z</td><td>Z</td><td>ζ</td><td align="right">\zeta</td></tr><tr><td align="left">H</td><td>H</td><td>η</td><td>\eta</td><td>Θ</td><td>\Theta</td><td>θ</td><td align="right">\theta</td></tr><tr><td align="left">I</td><td>I</td><td>ι</td><td>\iota</td><td>K</td><td>K</td><td>κ</td><td align="right">\kappa</td></tr><tr><td align="left">Λ</td><td>\Lambda</td><td>λ</td><td>\lambda</td><td>M</td><td>M</td><td>μ</td><td align="right">\mu</td></tr><tr><td align="left">ν</td><td>\nu</td><td>Ξ</td><td>\Xi</td><td>ξ</td><td>\xi</td><td>ο</td><td align="right">\omicron</td></tr><tr><td align="left">Π</td><td>\Pi</td><td>π</td><td>\pi</td><td>ρ</td><td>\ρ</td><td>Σ</td><td align="right">\Sigma</td></tr><tr><td align="left">σ</td><td>\sigma</td><td>τ</td><td>\tau</td><td>Υ</td><td>\Upsilon</td><td>υ</td><td align="right">\upsilon</td></tr><tr><td align="left">Φ</td><td>\Phi</td><td>ϕ</td><td>\phi</td><td>χ</td><td>\chi</td><td>Ψ</td><td align="right">\Psi</td></tr><tr><td align="left">ψ</td><td>\psi</td><td>Ω</td><td>\v</td><td>ω</td><td>\omega</td><td></td><td align="right"></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 数学公式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> markDown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>公考资料之速算</title>
      <link href="/posts/23961/"/>
      <url>/posts/23961/</url>
      
        <content type="html"><![CDATA[<h2 id="资料分析之截位直除法"><a href="#资料分析之截位直除法" class="headerlink" title="资料分析之截位直除法"></a>资料分析之截位直除法</h2><ul><li>截位直除口诀<ol><li>选项差距大：4个选项首位不同，四舍五入保留前两位。</li><li>选项差距小：4个选项只要有两个首位相同，四舍五入保留前三位。</li></ol></li><li>直除步骤<ol><li>判断一步直除还是多步直除</li><li>如果是一步直除，就只截分母</li><li>如果是多步直除，那么分子分母都需要截位</li></ol>  <strong>例1</strong><ul><li>$\frac{4407}{1+17.7%}=\big(\big)$<br>A. 4280<br>B. 3744<br>C. 2983<br>D. 5347</li></ul>  <strong>【解析】</strong>首先观察选项，发现首位都不相同，所以是选项差距大，根据口诀，四舍五入保留前两位；接下来观察式子是一步直除，所以只截分母, 1+17.7%=1.177，四舍五入保留前两位为12，不需要考虑小数点，然后再运用除法运算，发现首位是3，只有B选项首位是3，所以选B。<br>  <strong>例2</strong><ul><li>$\frac{5698}{17608}=\big(\big)$<br>A. 29.5%<br>B. 32.4%<br>C. 33.7%<br>D. 34.6%</li></ul>  <strong>【解析】</strong>首先观察选项，发现首位BCD都相同，所以是选项差距小，根据口诀，四舍五入保留前三位；接下来观察式子是一步直除，所以只截分母，分母17608四舍五入保留前三位为176，不需要考虑小数点，然后再运用除法运算，发现是32开头的，只有B选项首位是3，所以选B。<br>  <strong>例3</strong><ul><li>$\frac{17778}{1+18.9%} \div \frac{522002.45}{1+11.8%}=\big(\big)$<br>A. 29.5%<br>B. 32.4%<br>C. 33.7%<br>D. 34.6%</li></ul>  <strong>【解析】</strong>首先观察选项，发现首位都不相同，所以是选项差距大，根据口诀，四舍五入保留前两位；接下来观察式子是多步直除，所以分子和分母都需要截位，前面分数分子17778，四舍五入保留前两位为18，不需要考虑小数点，分母1+18.9%=1.189，四舍五入保留前两位为12，不需要考虑小数点，后面分数分子522002.45，四舍五入保留前两位为18，不需要考虑小数点，分母1+11.8%=1.118，四舍五入保留前两位为11，不需要考虑小数点，截位之后，不要着急进行除法运算，先化除为乘，然后进行约分，简化计算，化简到最简式，分子和分母分别计算出来，33/104明显首位是3，只有A选项的首位是3，所以选A选项。<code>“直除法”是资料分析的速算第一法</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> 资料分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 公考 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决github拉代码慢</title>
      <link href="/posts/57554/"/>
      <url>/posts/57554/</url>
      
        <content type="html"><![CDATA[<h2 id="解决从-github-上拉取代码慢的问题"><a href="#解决从-github-上拉取代码慢的问题" class="headerlink" title="解决从 github 上拉取代码慢的问题"></a>解决从 github 上拉取代码慢的问题</h2><ol><li>获取<em>Github<em>相关网站的</em>ip</em><ul><li>访问 <a href="https://www.ipaddress.com" target="_blank" rel="noopener">IP地址查询网站</a>,找到页面中下方的IP Address Tools - lookup,分别输入</li><li><code>github.global.ssl.fastly.net</code>和<code>github.com</code>，查询 ip 地址。</li></ul></li><li>修改本地 <em>host</em> 文件<ul><li>Mac 为例，命令行下输入：<code>sudo vi /etc/host</code>，然后输入电脑的密码，打开 host 文件。</li><li>Window 为例 <code>C:\Windows\System32\drivers\etc</code></li></ul></li><li>增加 <em>host</em> 映射<br>  <strong>参考如下:</strong> <pre><code>  151.101.113.194   github.global.ssl.fastly.net   192.30.253.112   github.com</code></pre></li><li>更新 DNS 缓存<br>命令行输入:<code>ipconfig /flushdns</code>,使增加的映射生效。</li></ol>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 项目管理工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git代码上传至指定仓库</title>
      <link href="/posts/22612/"/>
      <url>/posts/22612/</url>
      
        <content type="html"><![CDATA[<h2 id="使用命令将本地项目上传至github"><a href="#使用命令将本地项目上传至github" class="headerlink" title="使用命令将本地项目上传至github"></a>使用命令将本地项目上传至github</h2><ol><li>（先进入项目文件夹）通过命令<code>git init</code>把这个目录变成 git 可以管理的仓库<br><code>git init</code></li><li>把文件添加到版本库中，使用命令 git add . 添加到暂存区里面去，不要忘记后面的小数点 “.”，意为添加文件夹下的所有文件<br><code>git add .</code></li><li>用命令 git commit 告诉 Git，把文件提交到仓库。引号内为提交说明<br><code>git commit -m &#39;first commit&#39;</code></li><li>关联到远程库如下:<br><code>git remote add origin https://github.com/githubusername/demo.git</code></li><li>获取远程库与本地同步合并（如果远程库不为空必须做这一步，否则后面的提交会失败）<br><code>git pull --rebase origin master</code></li><li>把本地库的内容推送到远程，使用 git push 命令，实际上是把当前分支 master 推送到远程。执行此命令后会要求输入用户名、密码，验证通过后即开始上传。<br><code>git push -u origin master</code></li><li>状态查询命令<br><code>git status</code><h2 id="git常用命令图"><a href="#git常用命令图" class="headerlink" title="git常用命令图:"></a>git常用命令图:</h2><img src="../../../image/gitComand001.png" alt></li></ol>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 项目管理工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/posts/16107/"/>
      <url>/posts/16107/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>JQuery</title>
      <link href="/posts/63260/"/>
      <url>/posts/63260/</url>
      
        <content type="html"><![CDATA[<p>@[toc]</p><h2 id="JQuery是什么"><a href="#JQuery是什么" class="headerlink" title="JQuery是什么"></a>JQuery是什么</h2><p>jQuery由美国人John Resig创建，至今已吸引了来自世界各地的众多javascript高手加入其team。<br>其宗旨是——WRITE LESS,DO MORE,写更少的代码,做更多的事情。<br>它是轻量级的js库(压缩后只有21k) ，还兼容各种浏览器<br>jQuery是一个快速的，简洁的javaScript库，使用户能更方便地处理HTML documents、events、实现动画效果，并且方便地为网站提供AJAX交互。<br>jQuery还有一个比较大的优势是，它的文档说明很全，而且各种应用也说得很详细，同时还有许多成熟的插件可供选择。</p><h2 id="JQuery的引入"><a href="#JQuery的引入" class="headerlink" title="JQuery的引入"></a>JQuery的引入</h2><pre><code>&lt;script type=&quot;text/javascript&quot; src=&quot;script/jquery-1.8.3.js&quot;&gt;&lt;/script&gt;</code></pre><h3 id="加载主函数"><a href="#加载主函数" class="headerlink" title="加载主函数"></a>加载主函数</h3><h4 id="第一种方式"><a href="#第一种方式" class="headerlink" title="第一种方式"></a>第一种方式</h4><pre><code>$(document).ready(function(){    var div1 = document.getElementById(&quot;div1&quot;);    alert(div1);});</code></pre><h4 id="第二种方式"><a href="#第二种方式" class="headerlink" title="第二种方式"></a>第二种方式</h4><pre><code>$(function(){    var div1 = document.getElementById(&quot;div1&quot;)    alert(div1)})</code></pre><h2 id="什么是JQuery对象"><a href="#什么是JQuery对象" class="headerlink" title="什么是JQuery对象"></a>什么是JQuery对象</h2><p>jQuery 对象就是通过jQuery包装DOM对象后产生的对象。<br>jQuery 对象是 jQuery 独有的. 如果一个对象是 jQuery 对象, 那么它就可以使用 jQuery 里的方法。<br>虽然jQuery对象是包装DOM对象后产生的，但是jQuery无法使用DOM对象的任何方法，同理DOM对象也不能使用jQuery里的方法.乱使用会报错</p><h3 id="JQuery对象和DOM对象之间的转换"><a href="#JQuery对象和DOM对象之间的转换" class="headerlink" title="JQuery对象和DOM对象之间的转换"></a>JQuery对象和DOM对象之间的转换</h3><p>第一种 <em>DOM对象转成JQuery对象</em><br>对于已经是一个DOM对象，只需要用$()把DOM对象包装起来，就可以获得一个jQuery对象了。$(DOM对象) ;<br>代码如下：</p><pre><code>function myclick(){    var div1 = document.getElementById(&quot;myinput&quot;);    //把dom转换成jQuery对象    var jdiv1 = $(div1);    alert(jdiv1.val());}</code></pre><p>第二种 <em>JQuery对象转成DOM对象</em><br>代码如下:</p><pre><code>function myclick(){    var div1 = document.getElementById(&quot;myinput&quot;);    //把dom转换成jQuery对象    var jdiv1 = $(div1);    //把jQuery对象转换成dom对象    alert(jdiv1[0].value);    alert(jdiv1.get(0).value);}</code></pre><h2 id="JQuery选择器"><a href="#JQuery选择器" class="headerlink" title="JQuery选择器"></a>JQuery选择器</h2><h3 id="基本选择器"><a href="#基本选择器" class="headerlink" title="基本选择器"></a>基本选择器</h3><table><thead><tr><th align="center">元素</th><th align="left">用法</th><th align="center">返回值</th><th>说明</th></tr></thead><tbody><tr><td align="center">#id</td><td align="left">$(”#myDiv”)</td><td align="center">单个元素的组成的集合</td><td>直接选择html中的id=”myDiv”</td></tr><tr><td align="center">Element</td><td align="left">$(”div”)</td><td align="center">集合元素</td><td>element其实就是html已经定义的标签元素</td></tr><tr><td align="center">class</td><td align="left">$(”.myClass”)</td><td align="center">集合元素</td><td>选择html代码中class=”myClass”的元素或元素组</td></tr><tr><td align="center">*</td><td align="left">$(”*”)</td><td align="center">集合元素</td><td>匹配所有元素</td></tr><tr><td align="center">selector1, selector2, selectorN</td><td align="left">$(”div,span,p.myClass”)</td><td align="center">集合元素</td><td>每一个选择器匹配到的元素合并后一起返回</td></tr></tbody></table><h3 id="层次选择器"><a href="#层次选择器" class="headerlink" title="层次选择器"></a>层次选择器</h3><table><thead><tr><th align="center">元素</th><th align="left">用法</th><th align="left">返回值</th><th>说明</th></tr></thead><tbody><tr><td align="center">祖下的后代(ancestor descendant)</td><td align="left">$(”form input”)</td><td align="left">集合元素</td><td>给定的祖先元素下匹配所有后代元素</td></tr><tr><td align="center">父下的子(parent &gt; child)</td><td align="left">$(”form &gt; input”)</td><td align="left">集合元素</td><td>给定的父元素下匹配所有子元素.注意:要区分好后代元素与子元素</td></tr><tr><td align="center">(prev + next)</td><td align="left">$(”label + input”)</td><td align="left">集合元素</td><td>匹配所有紧接在prev元素后的next元素</td></tr><tr><td align="center">(prev ~ siblings)</td><td align="left">$(”form ~ input”)</td><td align="left">集合元素</td><td>匹配prev元素之后的所有siblings元素,兄弟辈的,也就是说匹配的是和prev同辈元素</td></tr></tbody></table><h3 id="过滤选择器"><a href="#过滤选择器" class="headerlink" title="过滤选择器"></a>过滤选择器</h3><p><em>过滤选择器主要是通过特定的过滤规则来筛选出所需的 DOM 元素, 该选择器都以 “:” 开头</em></p><h4 id="基本过滤选择器"><a href="#基本过滤选择器" class="headerlink" title="基本过滤选择器"></a>基本过滤选择器</h4><table><thead><tr><th align="center">元素</th><th align="left">用法</th><th align="center">返回值</th><th align="right">说明</th></tr></thead><tbody><tr><td align="center">:first</td><td align="left">$(”tr:first”)</td><td align="center">单个元素的组成的集合</td><td align="right">匹配找到的第一个元素(第一个tr)</td></tr><tr><td align="center">:last</td><td align="left">$(”tr:last”)</td><td align="center">单个元素的组成的集合</td><td align="right">匹配找到的最后一个元素.(最后一个tr)</td></tr><tr><td align="center">:not(selector)</td><td align="left">$(”input:not(:checked)”)</td><td align="center">集合元素</td><td align="right">意思是没有被选中的input(当input的type=”checkbox”)</td></tr><tr><td align="center">:even</td><td align="left">$(”tr:even”)</td><td align="center">集合元素</td><td align="right">匹配所有索引值为偶数的元素(table中的第一个tr就为偶数0)</td></tr><tr><td align="center">:odd</td><td align="left">$(”tr:odd”)</td><td align="center">集合元素</td><td align="right">匹配所有索引值为奇数的元素</td></tr><tr><td align="center">:eq(index)</td><td align="left">$(”tr:eq(0)”)</td><td align="center">集合元素</td><td align="right">匹配一个给定索引值的元素(eq(0)就是获取第一个tr元素)</td></tr><tr><td align="center">:gt(index)</td><td align="left">$(”tr:gt(0)”)</td><td align="center">集合元素</td><td align="right">匹配所有大于给定索引值的元素</td></tr><tr><td align="center">:lt(index)</td><td align="left">$(”tr:lt(2)”)</td><td align="center">集合元素</td><td align="right">匹配所有小于给定索引值的元素.</td></tr><tr><td align="center">:header(固定写法)</td><td align="left">$(”:header”).css(”background”,“#EEE”)</td><td align="center">集合元素</td><td align="right">匹配如 h1, h2之类的标题元素,这个是专门用来获取h1,h2这样的标题元素</td></tr><tr><td align="center">:animated(固定写法)</td><td align="left">$(”:animated”)</td><td align="center">集合元素</td><td align="right">匹配所有正在执行动画效果的元素</td></tr></tbody></table><h4 id="属性过滤选择器"><a href="#属性过滤选择器" class="headerlink" title="属性过滤选择器"></a>属性过滤选择器</h4><table><thead><tr><th align="center">元素</th><th align="left">用法</th><th align="center">返回值</th><th align="right">说明</th></tr></thead><tbody><tr><td align="center">[attribute]</td><td align="left">$(”div[id]“)</td><td align="center">集合元素</td><td align="right">匹配包含给定属性的元素(例子选取的是“id”属性的div标签)</td></tr><tr><td align="center">[attribute=value]</td><td align="left">$(”input[name=’newsletter’]“)</td><td align="center">集合元素</td><td align="right">匹配给定的属性是某个特定值的元素</td></tr><tr><td align="center">[attribute!=value]</td><td align="left">$(”input[name!=’newsletter’]“)</td><td align="center">集合元素</td><td align="right">匹配所有不含有指定的属性,或者属性不等于特定值的元素</td></tr><tr><td align="center">[attribute^=value]</td><td align="left">$(”input[name^=‘news’]“)</td><td align="center">集合元素</td><td align="right">匹配给定的属性是以某些值开始的元素</td></tr><tr><td align="center">[attribute$=value]</td><td align="left">$(”input[name$=‘letter’]“)</td><td align="center">集合元素</td><td align="right">匹配给定的属性是以某些值结尾的元素</td></tr><tr><td align="center">[attribute*=value]</td><td align="left">$(”input[name*=‘man’]“)</td><td align="center">集合元素</td><td align="right">匹配给定的属性是以包含某些值的元素</td></tr><tr><td align="center">[attributeFilter1][attributeFilterN]</td><td align="left">$(”input[id][name$=‘man’]“)</td><td align="center">集合元素</td><td align="right">复合属性选择器,需要同时满足多个条件时使用</td></tr></tbody></table><h4 id="子元素过滤选择器"><a href="#子元素过滤选择器" class="headerlink" title="子元素过滤选择器"></a>子元素过滤选择器</h4><table><thead><tr><th align="center">元素</th><th align="left">用法</th><th align="center">返回值</th><th align="right">说明</th></tr></thead><tbody><tr><td align="center">:nth-child(index)</td><td align="left">$(”ul li:nth-child(2)”)</td><td align="center">集合元素</td><td align="right">匹配其父元素下的第N个子或奇偶元素(本例种取得是第二个子元素),这个索引是从1开始</td></tr><tr><td align="center">:first-child</td><td align="left">$(”ul li:first-child”)</td><td align="center">集合元素</td><td align="right">匹配第一个子元素(本例代表取每个ul下的第一个子元素)</td></tr><tr><td align="center">:last-child</td><td align="left">$(”ul li:last-child”)</td><td align="center">集合元素</td><td align="right">匹配每个父下的最后一个子元素</td></tr><tr><td align="center">:only-child</td><td align="left">$(”ul li:only-child”)</td><td align="center">集合元素</td><td align="right">如果某个元素是父元素中唯一的子元素,那将会被匹配:(意思是只有一个子元素才匹配)</td></tr></tbody></table><h4 id="表单对象属性过滤选择器"><a href="#表单对象属性过滤选择器" class="headerlink" title="表单对象属性过滤选择器"></a>表单对象属性过滤选择器</h4><p><em>此选择器主要对所选择的表单元素进行过滤</em></p><table><thead><tr><th align="center">元素</th><th align="left">用法</th><th align="center">返回值</th><th align="right">说明</th></tr></thead><tbody><tr><td align="center">:enabled</td><td align="left">$(”input:enabled”)</td><td align="center">集合元素</td><td align="right">匹配所有可用元素(意思是不带有disabled=”disabled”的元素)</td></tr><tr><td align="center">:disabled</td><td align="left">$(”input:disabled”)</td><td align="center">集合元素</td><td align="right">匹配所有不可用元素(意思是带有disabled=”disabled”的元素)</td></tr><tr><td align="center">:checked</td><td align="left">$(”input:checked)</td><td align="center">集合元素</td><td align="right">匹配所有选中的被选中元素(复选框</td></tr><tr><td align="center">:selected</td><td align="left">$(”select option:selected”)</td><td align="center">集合元素</td><td align="right">匹配所有选中的option元素</td></tr></tbody></table><h4 id="表单选择器"><a href="#表单选择器" class="headerlink" title="表单选择器"></a>表单选择器</h4><table><thead><tr><th align="center">元素</th><th align="left">用法</th><th align="center">返回值</th><th align="right">说明</th></tr></thead><tbody><tr><td align="center">:input</td><td align="left">$(”:input”)</td><td align="center">集合元素</td><td align="right">匹配所有 input, textarea, select 和 button 元素</td></tr><tr><td align="center">:text</td><td align="left">$(”:text)</td><td align="center">集合元素</td><td align="right">匹配所有的单行文本框</td></tr><tr><td align="center">:password</td><td align="left">$(”:password)</td><td align="center">集合元素</td><td align="right">匹配所有密码框</td></tr><tr><td align="center">:radio</td><td align="left">$(”:radio)</td><td align="center">集合元素</td><td align="right">匹配所有单选按钮</td></tr><tr><td align="center">:checkbox</td><td align="left">$(”:checkbox)</td><td align="center">集合元素</td><td align="right">匹配所有复选框</td></tr><tr><td align="center">:submit</td><td align="left">$(”:submit)</td><td align="center">集合元素</td><td align="right">匹配所有提交按钮</td></tr><tr><td align="center">:image</td><td align="left">$(”:image)</td><td align="center">集合元素</td><td align="right">匹配所有图像域</td></tr><tr><td align="center">:reset</td><td align="left">$(”:reset)</td><td align="center">集合元素</td><td align="right">匹配所有重置按钮</td></tr><tr><td align="center">:button</td><td align="left">$(”:button)</td><td align="center">集合元素</td><td align="right">匹配所有按钮.这个包括直接写的元素button</td></tr><tr><td align="center">:file</td><td align="left">$(”:file)</td><td align="center">集合元素</td><td align="right">匹配所有文件域.</td></tr><tr><td align="center">:hidden</td><td align="left">$(”:hidden)</td><td align="center">集合元素</td><td align="right">匹配所有不可见元素,或者type为hidden的元素,这个选择器就不仅限于表单,那些style为hidden的也会被匹配</td></tr></tbody></table><h2 id="JQuery中的DOM操作"><a href="#JQuery中的DOM操作" class="headerlink" title="JQuery中的DOM操作"></a>JQuery中的DOM操作</h2><p>DOM(Document Object Model—文档对象模型):一种与浏览器,平台,语言无关的接口,使用该接口可以轻松地访问页面中所有的标准组件</p><ol><li>append(content) :向每个匹配的元素的内部的结尾处追加内容</li></ol><p><strong>代码示例:</strong></p><pre><code>function myclick(){    var len = $(&quot;li&quot;).length;    //创建li的jQuery元素    var liObj = $(&quot;&lt;li&gt;列表项&quot;+(len+1)+&quot;&lt;/li&gt;&quot;);    //在ul内追加jQuery的li元素    $(&quot;ul&quot;).append(liObj);}&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;ul&gt;    &lt;li&gt;列表项1&lt;/li&gt;    &lt;li&gt;列表项2&lt;/li&gt;    &lt;li&gt;列表项3&lt;/li&gt;    &lt;li&gt;列表项4&lt;/li&gt;&lt;/ul&gt;</code></pre><ol start="2"><li>appendTo(content) :将每个匹配的元素追加到指定的元素中的内部结尾处</li></ol><p><strong>代码示例:</strong></p><pre><code>function myclick(){    var len = $(&quot;li&quot;).length;    //创建li的jQuery元素    var liObj = $(&quot;&lt;li&gt;列表项&quot;+(len+1)+&quot;&lt;/li&gt;&quot;);    //在ul内追加jQuery的li元素    //$(&quot;ul&quot;).append(liObj);    var urlObj = $(&quot;ul&quot;);    liObj.appendTo(urlObj);}</code></pre><ol start="3"><li>prepend(content):向每个匹配的元素的内部的开始处插入内容</li></ol><p><strong>代码示例:</strong></p><pre><code>    var len = $(&quot;li&quot;).length;    //创建li的jQuery元素    var liObj = $(&quot;&lt;li&gt;列表项&quot;+(len+1)+&quot;&lt;/li&gt;&quot;);    //在ul内追加jQuery的li元素    //$(&quot;ul&quot;).append(liObj);    /* var urlObj = $(&quot;ul&quot;);    liObj.appendTo(urlObj); */    /* $(&quot;ul&quot;).prepend(liObj);     var urlObj = $(&quot;ul&quot;); */     var urlObj = $(&quot;ul&quot;);    liObj.prependTo(urlObj);</code></pre><ol start="4"><li>prependTo(content) :将每个匹配的元素插入到指定的元素内部的开始处</li></ol><p><strong>代码示例:</strong></p><pre><code>function myclick(){    var len = $(&quot;li&quot;).length;    //创建li的jQuery元素    var liObj = $(&quot;&lt;li&gt;列表项&quot;+(len+1)+&quot;&lt;/li&gt;&quot;);    //在ul内追加jQuery的li元素    //$(&quot;ul&quot;).append(liObj);    /* var urlObj = $(&quot;ul&quot;);    liObj.appendTo(urlObj); */    $(&quot;ul&quot;).prepend(liObj);}</code></pre><h3 id="JQuery中的DOM操作应用"><a href="#JQuery中的DOM操作应用" class="headerlink" title="JQuery中的DOM操作应用"></a>JQuery中的DOM操作应用</h3><p><img src="../../../image/JqueryDomOpera003.png" alt><br><strong>代码示例:</strong></p><pre><code>&lt;script type=&quot;text/javascript&quot;&gt;/* var myclick = function(){    alert(&quot;0&quot;);} */$(function(){})function rightMove(){    //获得左面被选中的option    $(&quot;#perm option&quot;).each(function(){        //获得每一个option的是否被选中的属性值        var opt = $(this).attr(&quot;selected&quot;);        if(opt == &quot;selected&quot;){            $(&quot;#selPerm&quot;).append($(this));        }    })}function rightMoveAll(){    //获得左面被选中的option    $(&quot;#perm option&quot;).each(function(){        //var copy = $(this).clone();        $(&quot;#selPerm&quot;).append($(this));    })}function leftMove(){    //获得左面被选中的option    $(&quot;#selPerm option&quot;).each(function(){        //获得每一个option的是否被选中的属性值        var opt = $(this).attr(&quot;selected&quot;);        if(opt == &quot;selected&quot;){            $(&quot;#perm&quot;).append($(this));        }    })}function leftMoveAll(){    //获得左面被选中的option    $(&quot;#selPerm option&quot;).each(function(){        $(&quot;#perm&quot;).append($(this));    })}&lt;/script&gt;&lt;style type=&quot;text/css&quot;&gt;select{    width: 200px;    height: 200px;}&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;table&gt;    &lt;tr&gt;        &lt;td&gt;            &lt;select id=&quot;perm&quot; multiple=&quot;multiple&quot;&gt;                &lt;option&gt;登录&lt;/option&gt;                &lt;option&gt;员工管理&lt;/option&gt;                &lt;option&gt;部门管理&lt;/option&gt;                &lt;option&gt;订单管理&lt;/option&gt;            &lt;/select&gt;        &lt;/td&gt;        &lt;td&gt;            &lt;input type=&quot;button&quot; value=&quot;&gt;&quot; onclick=&quot;rightMove()&quot;&gt;&lt;br&gt;            &lt;input type=&quot;button&quot; value=&quot;&gt;&gt;&quot; onclick=&quot;rightMoveAll()&quot;&gt;&lt;br&gt;            &lt;input type=&quot;button&quot; value=&quot;&amp;lt&quot; onclick=&quot;leftMove()&quot;&gt;&lt;br&gt;            &lt;input type=&quot;button&quot; value=&quot;&amp;lt&amp;lt&quot; onclick=&quot;leftMoveAll()&quot;&gt;        &lt;/td&gt;        &lt;td&gt;            &lt;select id=&quot;selPerm&quot; multiple=&quot;multiple&quot;&gt;            &lt;/select&gt;        &lt;/td&gt;    &lt;/tr&gt;&lt;/table&gt;</code></pre><h3 id="外部插入节点"><a href="#外部插入节点" class="headerlink" title="外部插入节点"></a>外部插入节点</h3><ol><li>after(content) :在每个匹配的元素之后插入内容 </li><li>before(content):在每个匹配的元素之前插入内容 </li></ol><p><strong>以上方法不但能将新创建的 DOM 元素插入到文档中, 也能对原有的 DOM 元素进行移动.</strong></p><h3 id="创建节点"><a href="#创建节点" class="headerlink" title="创建节点"></a>创建节点</h3><p>使用 jQuery 的工厂函数 $(): $(html); 会根据传入的 html 标记字符串创建一个 DOM 对象, 并把这个 DOM 对象包装成一个 jQuery 对象返回<br><strong>注意</strong><br>动态创建的新元素节点不会被自动添加到文档中, 而是需要使用其他方法将其插入到文档中;<br>当创建单个元素时, 需注意闭合标签和使用标准的 XHTML 格式. 例如创建一个</p><p>元素, 可以使用 $(“</p><p>”) 或 $(“</p><p></p>”), 但不能使用 $(“<p>”) 或 $(“</p>”)<br>创建文本节点就是在创建元素节点时直接把文本内容写出来; 创建属性节点也是在创建元素节点时一起创建<p></p><h3 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h3><p><strong>remove():</strong><br>    从 DOM 中删除所有匹配的元素, 传入的参数用于根据 jQuery 表达    式来筛选元素. 当某个节点用 remove() 方法删除后, 该节点所包含的    所有后代节点将被同时删除. 这个方法的返回值是一个指向已被删除    的节点的引用.<br><strong>empty():</strong><br>    清空节点 – 清空元素中的所有后代节点(不包含属性节点).</p><h3 id="复制节点"><a href="#复制节点" class="headerlink" title="复制节点"></a>复制节点</h3><p><strong>clone():</strong><br>克隆匹配的 DOM 元素, 返回值为克隆后的副本. 但此时复制的新节点不具有任何行为.<br><strong>clone(true):</strong><br>复制元素的同时也复制元素中的的事件<br><strong>代码示例:</strong></p><pre><code>&lt;script type=&quot;text/javascript&quot;&gt;$(function(){    $(&quot;#div1&quot;).click(function(){        alert(&quot;div1的点击事件&quot;);    })})function copy(){    var divObj = $(&quot;#div1&quot;);    //如果带着true的参数复制就会把事件也复制过去，如果不去指定参数就不会复制事件    var divObjcopy = divObj.clone(true);    $(&quot;#div2&quot;).after(divObjcopy);}&lt;/script&gt;</code></pre><h3 id="属性操作"><a href="#属性操作" class="headerlink" title="属性操作"></a>属性操作</h3><p><strong>attr():</strong><br>获取属性和设置属性</p><ul><li>当为该方法传递一个参数时, 即为某元素的获取指定属性</li><li>当为该方法传递两个参数时, 即为某元素设置指定属性的值<br>jQuery 中有很多方法都是一个函数实现获取和设置. 如: attr(), html(), text(), val(), height(), width(), css() 等.</li></ul><p><strong>removeAttr():</strong><br>删除指定元素的指定属性</p><h3 id="样式操作"><a href="#样式操作" class="headerlink" title="样式操作"></a>样式操作</h3><p><strong>获取class和设置class:</strong><br>class是元素的一个属性,所以获取class和设置class都可以使用attr()方法来完成.<br><strong>追加样式:</strong><br>addClass()<br><strong>移除样式:</strong><br>removeClass() 从匹配的元素中删除全部或指定的class<br><strong>切换样式:</strong><br>toggleClass() 控制样式上的重复切换.如果类名存在则删除它,如果类名不存在则添加它.<br><strong>判断是否含有某个样式:</strong><br>hasClass() 判断元素中是否含有某个class,如果有,则返回true;否则返回false</p><h3 id="设置获取HTML-文本和值"><a href="#设置获取HTML-文本和值" class="headerlink" title="设置获取HTML,文本和值"></a>设置获取HTML,文本和值</h3><p><strong>读取和设置某个元素中的HTML内容:</strong><br>html() 该方法可以用于 XHTML, 但不能用于 XML 文档<br><strong>读取和设置某个元素中的文本内容:</strong><br>text() 该方法既可以用于 XHTML 也可以用于 XML 文档.<br><strong>读取和设置某个元素中的值:</strong><br>val() 该方法类似 JavaScript 中的 value 属性. 对于文本框, 下拉列表框, 单选框该方法可返回元素的值(多选框只能返回第一个值).如果为多选下拉列表框, 则返回一个包含所有选择值的数组</p><h3 id="常用的遍历节点方法"><a href="#常用的遍历节点方法" class="headerlink" title="常用的遍历节点方法"></a>常用的遍历节点方法</h3><p><strong>取得匹配元素的所有子元素组成的集合:</strong><br>children(). 该方法只考虑子元素而不考虑任何后代元素.<br><strong>取得匹配元素后面紧邻的同辈元素的集合:</strong><br>next();<br><strong>取得匹配元素前面紧邻的同辈元素的集合:</strong><br>prev()<br><strong>取得匹配元素前后所有的同辈元素:</strong><br>siblings()<br><strong>代码示例</strong></p><pre><code>&lt;script type=&quot;text/javascript&quot;&gt;function myclick(){    /* $(&quot;ul li&quot;).each(function(){        alert($(this).html())    }) */    //获得ul下的孩子节点    var lis = $(&quot;ul&quot;).children();    lis.each(function(){        alert($(this).html())    })}function myclick1(){    //siblings获得兄弟节点    $(&quot;div p:first-child&quot;).siblings().each(function(){        alert($(this).html())    })}function login(){    //根据id选择器获得用户名的jQuery对象    var unameObj = $(&quot;#username&quot;);    var val = unameObj.val();    var reg = unameObj.attr(&quot;reg&quot;);    var tip = unameObj.attr(&quot;tip&quot;);    var regObj = new RegExp(reg);    if(!regObj.test(val)){        //获得username紧挨着的下一个dom的jQuery对象        var spanObj = unameObj.next(&quot;input&quot;);        spanObj.html(tip);    }else{        //提交表单        $(&quot;#myform&quot;).submit();    }}&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;ul&gt;    &lt;li&gt;列表项1&lt;/li&gt;    &lt;li&gt;列表项2&lt;/li&gt;    &lt;li&gt;列表项3&lt;/li&gt;    &lt;li&gt;列表项4&lt;/li&gt;&lt;/ul&gt;&lt;input type=&quot;button&quot; value=&quot;点击&quot; onclick=&quot;myclick()&quot;&gt;&lt;hr&gt;&lt;form id=&quot;myform&quot; action=&quot;${path }/jsp2/tab.jsp&quot; method=&quot;post&quot;&gt;    &lt;p&gt;        用户名：&lt;input id=&quot;username&quot; name=&quot;username&quot; type=&quot;text&quot; reg=&quot;^\w{6,8}$&quot; tip=&quot;请输入6到8位的单词字符&quot;&gt;&lt;span&gt;&lt;/span&gt;    &lt;/p&gt;    &lt;p&gt;        &lt;input type=&quot;button&quot; value=&quot;登录&quot; onclick=&quot;login()&quot;&gt;    &lt;/p&gt;&lt;/form&gt;</code></pre><h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><ol><li>事件结合选择器会把选择器选出来的一组元素都加上事件</li><li>在元素上可以不去指定事件</li><li>事件的方法建议使用匿名方法</li><li>事件的赋值必须要放在jQuery的主函数内部</li></ol><p>提供可以绑定的事件有:</p><table><thead><tr><th align="center">-</th><th align="center">-</th><th align="center">-</th><th align="center">-</th></tr></thead><tbody><tr><td align="center">blur</td><td align="center">focus</td><td align="center">focusin</td><td align="center">focusout</td></tr><tr><td align="center">load</td><td align="center">resize</td><td align="center">scroll</td><td align="center">unload</td></tr><tr><td align="center">click</td><td align="center">dblclick</td><td align="center">mousedown</td><td align="center">mouseup</td></tr><tr><td align="center">mousemove</td><td align="center">mouseover</td><td align="center">mouseout</td><td align="center">mouseenter</td></tr><tr><td align="center">mouseleave</td><td align="center">change</td><td align="center">select</td><td align="center">submit</td></tr><tr><td align="center">keydown</td><td align="center">keypress</td><td align="center">keyup</td><td align="center">error</td></tr></tbody></table><p><strong>代码示例:</strong></p><pre><code>&lt;script type=&quot;text/javascript&quot;&gt;$(function(){    /* 1.事件结合选择器会把选择器选出来的一组元素都加上事件       2.在元素上可以不去指定事件       3.事件的方法建议使用匿名方法       4.事件的赋值必须要放在jQuery的主函数内部    */    //离开焦点事件    $(&quot;form input&quot;).blur(function(){        //离开焦点的input是哪个这个this就是哪个对象        var obj = $(this);        var val = obj.val();        var reg = obj.attr(&quot;reg&quot;);        var tip = obj.attr(&quot;tip&quot;);        var regObj = new RegExp(reg);        if(!regObj.test(val)){            //获得username紧挨着的下一个dom的jQuery对象            var spanObj = obj.next();            spanObj.html(&quot;&lt;font color=&#39;red&#39;&gt;&quot;+tip+&quot;&lt;/font&gt;&quot;);        }else{            var spanObj = obj.next();            spanObj.html(&quot;&quot;);        }    });    //阻止表单提交事件    $(&quot;#myform&quot;).submit(function(){        var isSubmit =true;        $(&quot;form input&quot;).each(function(){            var obj = $(this);            var val = obj.val();            var reg = obj.attr(&quot;reg&quot;);            var tip = obj.attr(&quot;tip&quot;);            var regObj = new RegExp(reg);            if(!regObj.test(val)){                //获得username紧挨着的下一个dom的jQuery对象                var spanObj = obj.next();                spanObj.html(&quot;&lt;font color=&#39;red&#39;&gt;&quot;+tip+&quot;&lt;/font&gt;&quot;);                isSubmit =false;            }else{                var spanObj = obj.next();                spanObj.html(&quot;&quot;);            }        })        //阻止表单提交，如果是true就允许表单提交        return isSubmit;    });    //Keydown 按键事件    $(&quot;body&quot;).keydown(function(event){        var num = window.event?event.keyCode : event.which;        if(num == 13){            var isSubmit = true;            $(&quot;form input&quot;).each(function(){                var obj = $(this);                var val = obj.val();                var reg = obj.attr(&quot;reg&quot;);                var tip = obj.attr(&quot;tip&quot;);                var regObj = new RegExp(reg);                if(!regObj.test(val)){                    //获得username紧挨着的下一个dom的jQuery对象                    var spanObj = obj.next();                    spanObj.html(&quot;&lt;font color=&#39;red&#39;&gt;&quot;+tip+&quot;&lt;/font&gt;&quot;);                    isSubmit =false;                    //跳出each循环                    //return false;                }else{                    var spanObj = obj.next();                    spanObj.html(&quot;&quot;);                }            })            if(isSubmit){                //表单提交                $(&quot;#myform&quot;).submit();            }        }    });})&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;&quot;&gt;&lt;p&gt;    用户名：&lt;input name=&quot;username&quot; type=&quot;text&quot; reg=&quot;^\d{3,5}$&quot; tip=&quot;请输入3到5位的数字&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;    密码：&lt;input name=&quot;password&quot; type=&quot;password&quot; reg=&quot;^\w{6,8}$&quot; tip=&quot;请输入6到8位的英文或者数字或_&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;    地址：&lt;input name=&quot;address&quot; type=&quot;text&quot; reg=&quot;^.{0,50}$&quot; tip=&quot;请输入50个字符&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/form&gt;</code></pre><h3 id="ajax"><a href="#ajax" class="headerlink" title="ajax"></a>ajax</h3><p>type：请求方式get或者是post<br>url：请求地址<br>data：发送的数据<br>success是回调的数据方法<br>dataType：返回的数据类型json，text，xml，html<br>error：发生错误时</p><pre><code>function ajaxInvoke(){    var uname = $(&quot;#username&quot;).val();    $.ajax({        type:&#39;post&#39;,//请求方式        url:&#39;${path}/login&#39;,//请求的地址        async:false,//同步的ajax        data:{            username:uname//username=uname        },        dataType:&#39;json&#39;,//返回值的类型，一般使用两种，text，json        success:function(responseJSON){//ajax调用成功后的回调方法            alert(1);            //如果dataType是json那么要求后台一定要返回JSONObject或者JSONArray对象,这个后台的json对象会直接转换成js中的json            //alert(responseJSON.id+ &quot;  &quot;+responseJSON.name +&quot;   &quot;+responseJSON.age);            for(var i = 0; i &lt; responseJSON.length; i++){                alert(responseJSON[i].id + &quot;  &quot;+ responseJSON[i].name + &quot;  &quot;+responseJSON[i].age);            }        },        error:function(){//调用失败进入的方法            alert(&quot;系统错误&quot;);//如果404或者后台报异常就会走入error        }    });    //默认情况下ajax是异步的，所以程序不会等着回调函数执行完毕采取执行    alert(2);}</code></pre>]]></content>
      
      
      <categories>
          
          <category> JQuery </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>readis学习</title>
      <link href="/posts/62385/"/>
      <url>/posts/62385/</url>
      
        <content type="html"><![CDATA[<p>点击关注<a href="#公众号">公众号</a>及时获取笔主最新更新文章，并可免费领取本文档配套的《Java面试突击》以及Java工程师必备学习资源。</p><!-- TOC --><ul><li><a href="#redis-简介">redis 简介</a></li><li><a href="#为什么要用-redis为什么要用缓存">为什么要用 redis/为什么要用缓存</a></li><li><a href="#为什么要用-redis-而不用-mapguava-做缓存">为什么要用 redis 而不用 map/guava 做缓存?</a></li><li><a href="#redis-和-memcached-的区别">redis 和 memcached 的区别</a></li><li><a href="#redis-常见数据结构以及使用场景分析">redis 常见数据结构以及使用场景分析</a><ul><li><a href="#1string">1.String</a></li><li><a href="#2hash">2.Hash</a></li><li><a href="#3list">3.List</a></li><li><a href="#4set">4.Set</a></li><li><a href="#5sorted-set">5.Sorted Set</a></li></ul></li><li><a href="#redis-设置过期时间">redis 设置过期时间</a></li><li><a href="#redis-内存淘汰机制mysql里有2000w数据redis中只存20w的数据如何保证redis中的数据都是热点数据">redis 内存淘汰机制(MySQL里有2000w数据，Redis中只存20w的数据，如何保证Redis中的数据都是热点数据?)</a></li><li><a href="#redis-持久化机制怎么保证-redis-挂掉之后再重启数据可以进行恢复">redis 持久化机制(怎么保证 redis 挂掉之后再重启数据可以进行恢复)</a></li><li><a href="#redis-事务">redis 事务</a></li><li><a href="#缓存雪崩和缓存穿透问题解决方案">缓存雪崩和缓存穿透问题解决方案</a></li><li><a href="#如何解决-redis-的并发竞争-key-问题">如何解决 Redis 的并发竞争 Key 问题</a></li><li><a href="#如何保证缓存与数据库双写时的数据一致性">如何保证缓存与数据库双写时的数据一致性?</a></li></ul><!-- /TOC --><h3 id="redis-简介"><a href="#redis-简介" class="headerlink" title="redis 简介"></a>redis 简介</h3><p>简单来说 redis 就是一个数据库，不过与传统数据库不同的是 redis 的数据是存在内存中的，所以读写速度非常快，因此 redis 被广泛应用于缓存方向。另外，redis 也经常用来做分布式锁。redis 提供了多种数据类型来支持不同的业务场景。除此之外，redis 支持事务 、持久化、LUA脚本、LRU驱动事件、多种集群方案。 </p><h3 id="为什么要用-redis-为什么要用缓存"><a href="#为什么要用-redis-为什么要用缓存" class="headerlink" title="为什么要用 redis/为什么要用缓存"></a>为什么要用 redis/为什么要用缓存</h3><p>主要从“高性能”和“高并发”这两点来看待这个问题。</p><p><strong>高性能：</strong></p><p>假如用户第一次访问数据库中的某些数据。这个过程会比较慢，因为是从硬盘上读取的。将该用户访问的数据存在数缓存中，这样下一次再访问这些数据的时候就可以直接从缓存中获取了。操作缓存就是直接操作内存，所以速度相当快。如果数据库中的对应数据改变的之后，同步改变缓存中相应的数据即可！</p><p><img src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-9-24/54316596.jpg" alt></p><p><strong>高并发：</strong></p><p>直接操作缓存能够承受的请求是远远大于直接访问数据库的，所以我们可以考虑把数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不用经过数据库。</p><p><img src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-9-24/85146760.jpg" alt></p><h3 id="为什么要用-redis-而不用-map-guava-做缓存"><a href="#为什么要用-redis-而不用-map-guava-做缓存" class="headerlink" title="为什么要用 redis 而不用 map/guava 做缓存?"></a>为什么要用 redis 而不用 map/guava 做缓存?</h3><blockquote><p>下面的内容来自 segmentfault 一位网友的提问，地址：<a href="https://segmentfault.com/q/1010000009106416" target="_blank" rel="noopener">https://segmentfault.com/q/1010000009106416</a></p></blockquote><p>缓存分为本地缓存和分布式缓存。以 Java 为例，使用自带的 map 或者 guava 实现的是本地缓存，最主要的特点是轻量以及快速，生命周期随着 jvm 的销毁而结束，并且在多实例的情况下，每个实例都需要各自保存一份缓存，缓存不具有一致性。</p><p>使用 redis 或 memcached 之类的称为分布式缓存，在多实例的情况下，各实例共用一份缓存数据，缓存具有一致性。缺点是需要保持 redis 或  memcached服务的高可用，整个程序架构上较为复杂。</p><h3 id="redis-的线程模型"><a href="#redis-的线程模型" class="headerlink" title="redis 的线程模型"></a>redis 的线程模型</h3><blockquote><p>参考地址:<a href="https://www.javazhiyin.com/22943.html" target="_blank" rel="noopener">https://www.javazhiyin.com/22943.html</a></p></blockquote><p>redis 内部使用文件事件处理器 <code>file event handler</code>，这个文件事件处理器是单线程的，所以 redis 才叫做单线程的模型。它采用 IO 多路复用机制同时监听多个 socket，根据 socket 上的事件来选择对应的事件处理器进行处理。</p><p>文件事件处理器的结构包含 4 个部分：</p><ul><li>多个 socket</li><li>IO 多路复用程序</li><li>文件事件分派器</li><li>事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）</li></ul><p>多个 socket 可能会并发产生不同的操作，每个操作对应不同的文件事件，但是 IO 多路复用程序会监听多个 socket，会将 socket 产生的事件放入队列中排队，事件分派器每次从队列中取出一个事件，把该事件交给对应的事件处理器进行处理。</p><h3 id="redis-和-memcached-的区别"><a href="#redis-和-memcached-的区别" class="headerlink" title="redis 和 memcached 的区别"></a>redis 和 memcached 的区别</h3><p>对于 redis 和 memcached 我总结了下面四点。现在公司一般都是用 redis 来实现缓存，而且 redis 自身也越来越强大了！</p><ol><li><strong>redis支持更丰富的数据类型（支持更复杂的应用场景）</strong>：Redis不仅仅支持简单的k/v类型的数据，同时还提供list，set，zset，hash等数据结构的存储。memcache支持简单的数据类型，String。</li><li><strong>Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用,而Memecache把数据全部存在内存之中。</strong></li><li><strong>集群模式</strong>：memcached没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据；但是 redis 目前是原生支持 cluster 模式的.</li><li><strong>Memcached是多线程，非阻塞IO复用的网络模型；Redis使用单线程的多路 IO 复用模型。</strong></li></ol><blockquote><p>来自网络上的一张图，这里分享给大家！</p></blockquote><p><img src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-9-24/61603179.jpg" alt="redis 和 memcached 的区别"></p><h3 id="redis-常见数据结构以及使用场景分析"><a href="#redis-常见数据结构以及使用场景分析" class="headerlink" title="redis 常见数据结构以及使用场景分析"></a>redis 常见数据结构以及使用场景分析</h3><h4 id="1-String"><a href="#1-String" class="headerlink" title="1.String"></a>1.String</h4><blockquote><p><strong>常用命令:</strong>  set,get,decr,incr,mget 等。</p></blockquote><p>String数据结构是简单的key-value类型，value其实不仅可以是String，也可以是数字。<br>常规key-value缓存应用；<br>常规计数：微博数，粉丝数等。</p><h4 id="2-Hash"><a href="#2-Hash" class="headerlink" title="2.Hash"></a>2.Hash</h4><blockquote><p><strong>常用命令：</strong> hget,hset,hgetall 等。</p></blockquote><p>hash 是一个 string 类型的 field 和 value 的映射表，hash 特别适合用于存储对象，后续操作的时候，你可以直接仅仅修改这个对象中的某个字段的值。 比如我们可以 hash 数据结构来存储用户信息，商品信息等等。比如下面我就用 hash 类型存放了我本人的一些信息：</p><pre><code>key=JavaUser293847value={  “id”: 1,  “name”: “SnailClimb”,  “age”: 22,  “location”: “Wuhan, Hubei”}</code></pre><h4 id="3-List"><a href="#3-List" class="headerlink" title="3.List"></a>3.List</h4><blockquote><p><strong>常用命令:</strong> lpush,rpush,lpop,rpop,lrange等</p></blockquote><p>list 就是链表，Redis list 的应用场景非常多，也是Redis最重要的数据结构之一，比如微博的关注列表，粉丝列表，消息列表等功能都可以用Redis的 list 结构来实现。</p><p>Redis list 的实现为一个双向链表，即可以支持反向查找和遍历，更方便操作，不过带来了部分额外的内存开销。</p><p>另外可以通过 lrange 命令，就是从某个元素开始读取多少个元素，可以基于 list 实现分页查询，这个很棒的一个功能，基于 redis 实现简单的高性能分页，可以做类似微博那种下拉不断分页的东西（一页一页的往下走），性能高。</p><h4 id="4-Set"><a href="#4-Set" class="headerlink" title="4.Set"></a>4.Set</h4><blockquote><p><strong>常用命令：</strong><br>sadd,spop,smembers,sunion 等</p></blockquote><p>set 对外提供的功能与list类似是一个列表的功能，特殊之处在于 set 是可以自动排重的。</p><p>当你需要存储一个列表数据，又不希望出现重复数据时，set是一个很好的选择，并且set提供了判断某个成员是否在一个set集合内的重要接口，这个也是list所不能提供的。可以基于 set 轻易实现交集、并集、差集的操作。</p><p>比如：在微博应用中，可以将一个用户所有的关注人存在一个集合中，将其所有粉丝存在一个集合。Redis可以非常方便的实现如共同关注、共同粉丝、共同喜好等功能。这个过程也就是求交集的过程，具体命令如下：</p><pre><code>sinterstore key1 key2 key3     将交集存在key1内</code></pre><h4 id="5-Sorted-Set"><a href="#5-Sorted-Set" class="headerlink" title="5.Sorted Set"></a>5.Sorted Set</h4><blockquote><p><strong>常用命令：</strong> zadd,zrange,zrem,zcard等</p></blockquote><p>和set相比，sorted set增加了一个权重参数score，使得集合中的元素能够按score进行有序排列。</p><p><strong>举例：</strong> 在直播系统中，实时排行信息包含直播间在线用户列表，各种礼物排行榜，弹幕消息（可以理解为按消息维度的消息排行榜）等信息，适合使用 Redis 中的 Sorted Set 结构进行存储。</p><h3 id="redis-设置过期时间"><a href="#redis-设置过期时间" class="headerlink" title="redis 设置过期时间"></a>redis 设置过期时间</h3><p>Redis中有个设置时间过期的功能，即对存储在 redis 数据库中的值可以设置一个过期时间。作为一个缓存数据库，这是非常实用的。如我们一般项目中的 token 或者一些登录信息，尤其是短信验证码都是有时间限制的，按照传统的数据库处理方式，一般都是自己判断过期，这样无疑会严重影响项目性能。</p><p>我们 set key 的时候，都可以给一个 expire time，就是过期时间，通过过期时间我们可以指定这个 key 可以存活的时间。</p><p>如果假设你设置了一批 key 只能存活1个小时，那么接下来1小时后，redis是怎么对这批key进行删除的？</p><p><strong>定期删除+惰性删除。</strong></p><p>通过名字大概就能猜出这两个删除方式的意思了。</p><ul><li><strong>定期删除</strong>：redis默认是每隔 100ms 就<strong>随机抽取</strong>一些设置了过期时间的key，检查其是否过期，如果过期就删除。注意这里是随机抽取的。为什么要随机呢？你想一想假如 redis 存了几十万个 key ，每隔100ms就遍历所有的设置过期时间的 key 的话，就会给 CPU 带来很大的负载！</li><li><strong>惰性删除</strong> ：定期删除可能会导致很多过期 key 到了时间并没有被删除掉。所以就有了惰性删除。假如你的过期 key，靠定期删除没有被删除掉，还停留在内存里，除非你的系统去查一下那个 key，才会被redis给删除掉。这就是所谓的惰性删除，也是够懒的哈！</li></ul><p>但是仅仅通过设置过期时间还是有问题的。我们想一下：如果定期删除漏掉了很多过期 key，然后你也没及时去查，也就没走惰性删除，此时会怎么样？如果大量过期key堆积在内存里，导致redis内存块耗尽了。怎么解决这个问题呢？ <strong>redis 内存淘汰机制。</strong></p><h3 id="redis-内存淘汰机制-MySQL里有2000w数据，Redis中只存20w的数据，如何保证Redis中的数据都是热点数据"><a href="#redis-内存淘汰机制-MySQL里有2000w数据，Redis中只存20w的数据，如何保证Redis中的数据都是热点数据" class="headerlink" title="redis 内存淘汰机制(MySQL里有2000w数据，Redis中只存20w的数据，如何保证Redis中的数据都是热点数据?)"></a>redis 内存淘汰机制(MySQL里有2000w数据，Redis中只存20w的数据，如何保证Redis中的数据都是热点数据?)</h3><p>redis 配置文件 redis.conf 中有相关注释，我这里就不贴了，大家可以自行查阅或者通过这个网址查看： <a href="http://download.redis.io/redis-stable/redis.conf" target="_blank" rel="noopener">http://download.redis.io/redis-stable/redis.conf</a></p><p><strong>redis 提供 6种数据淘汰策略：</strong></p><ol><li><strong>volatile-lru</strong>：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰</li><li><strong>volatile-ttl</strong>：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰</li><li><strong>volatile-random</strong>：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰</li><li><strong>allkeys-lru</strong>：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key（这个是最常用的）</li><li><strong>allkeys-random</strong>：从数据集（server.db[i].dict）中任意选择数据淘汰</li><li><strong>no-eviction</strong>：禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报错。这个应该没人使用吧！</li></ol><p>4.0版本后增加以下两种：</p><ol start="7"><li><strong>volatile-lfu</strong>：从已设置过期时间的数据集(server.db[i].expires)中挑选最不经常使用的数据淘汰</li><li><strong>allkeys-lfu</strong>：当内存不足以容纳新写入数据时，在键空间中，移除最不经常使用的key</li></ol><p><strong>备注： 关于 redis 设置过期时间以及内存淘汰机制，我这里只是简单的总结一下，后面会专门写一篇文章来总结！</strong></p><h3 id="redis-持久化机制-怎么保证-redis-挂掉之后再重启数据可以进行恢复"><a href="#redis-持久化机制-怎么保证-redis-挂掉之后再重启数据可以进行恢复" class="headerlink" title="redis 持久化机制(怎么保证 redis 挂掉之后再重启数据可以进行恢复)"></a>redis 持久化机制(怎么保证 redis 挂掉之后再重启数据可以进行恢复)</h3><p>很多时候我们需要持久化数据也就是将内存中的数据写入到硬盘里面，大部分原因是为了之后重用数据（比如重启机器、机器故障之后恢复数据），或者是为了防止系统故障而将数据备份到一个远程位置。</p><p>Redis不同于Memcached的很重一点就是，Redis支持持久化，而且支持两种不同的持久化操作。<strong>Redis的一种持久化方式叫快照（snapshotting，RDB），另一种方式是只追加文件（append-only file,AOF）</strong>。这两种方法各有千秋，下面我会详细这两种持久化方法是什么，怎么用，如何选择适合自己的持久化方法。</p><p><strong>快照（snapshotting）持久化（RDB）</strong></p><p>Redis可以通过创建快照来获得存储在内存里面的数据在某个时间点上的副本。Redis创建快照之后，可以对快照进行备份，可以将快照复制到其他服务器从而创建具有相同数据的服务器副本（Redis主从结构，主要用来提高Redis性能），还可以将快照留在原地以便重启服务器的时候使用。</p><p>快照持久化是Redis默认采用的持久化方式，在redis.conf配置文件中默认有此下配置：</p><pre><code class="conf">save 900 1           #在900秒(15分钟)之后，如果至少有1个key发生变化，Redis就会自动触发BGSAVE命令创建快照。save 300 10          #在300秒(5分钟)之后，如果至少有10个key发生变化，Redis就会自动触发BGSAVE命令创建快照。save 60 10000        #在60秒(1分钟)之后，如果至少有10000个key发生变化，Redis就会自动触发BGSAVE命令创建快照。</code></pre><p><strong>AOF（append-only file）持久化</strong></p><p>与快照持久化相比，AOF持久化 的实时性更好，因此已成为主流的持久化方案。默认情况下Redis没有开启AOF（append only file）方式的持久化，可以通过appendonly参数开启：</p><pre><code class="conf">appendonly yes</code></pre><p>开启AOF持久化后每执行一条会更改Redis中的数据的命令，Redis就会将该命令写入硬盘中的AOF文件。AOF文件的保存位置和RDB文件的位置相同，都是通过dir参数设置的，默认的文件名是appendonly.aof。</p><p>在Redis的配置文件中存在三种不同的 AOF 持久化方式，它们分别是：</p><pre><code class="conf">appendfsync always    #每次有数据修改发生时都会写入AOF文件,这样会严重降低Redis的速度appendfsync everysec  #每秒钟同步一次，显示地将多个写命令同步到硬盘appendfsync no        #让操作系统决定何时进行同步</code></pre><p>为了兼顾数据和写入性能，用户可以考虑 appendfsync everysec选项 ，让Redis每秒同步一次AOF文件，Redis性能几乎没受到任何影响。而且这样即使出现系统崩溃，用户最多只会丢失一秒之内产生的数据。当硬盘忙于执行写入操作的时候，Redis还会优雅的放慢自己的速度以便适应硬盘的最大写入速度。</p><p><strong>Redis 4.0 对于持久化机制的优化</strong></p><p>Redis 4.0 开始支持 RDB 和 AOF 的混合持久化（默认关闭，可以通过配置项 <code>aof-use-rdb-preamble</code> 开启）。</p><p>如果把混合持久化打开，AOF 重写的时候就直接把 RDB 的内容写到 AOF 文件开头。这样做的好处是可以结合 RDB 和 AOF 的优点, 快速加载同时避免丢失过多的数据。当然缺点也是有的， AOF 里面的 RDB 部分是压缩格式不再是 AOF 格式，可读性较差。</p><p><strong>补充内容：AOF 重写</strong></p><p>AOF重写可以产生一个新的AOF文件，这个新的AOF文件和原有的AOF文件所保存的数据库状态一样，但体积更小。</p><p>AOF重写是一个有歧义的名字，该功能是通过读取数据库中的键值对来实现的，程序无须对现有AOF文件进行任何读入、分析或者写入操作。</p><p>在执行 BGREWRITEAOF 命令时，Redis 服务器会维护一个 AOF 重写缓冲区，该缓冲区会在子进程创建新AOF文件期间，记录服务器执行的所有写命令。当子进程完成创建新AOF文件的工作之后，服务器会将重写缓冲区中的所有内容追加到新AOF文件的末尾，使得新旧两个AOF文件所保存的数据库状态一致。最后，服务器用新的AOF文件替换旧的AOF文件，以此来完成AOF文件重写操作</p><p><strong>更多内容可以查看我的这篇文章：</strong></p><ul><li><a href="Redis持久化.md">Redis持久化</a></li></ul><h3 id="redis-事务"><a href="#redis-事务" class="headerlink" title="redis 事务"></a>redis 事务</h3><p>Redis 通过 MULTI、EXEC、WATCH 等命令来实现事务(transaction)功能。事务提供了一种将多个命令请求打包，然后一次性、按顺序地执行多个命令的机制，并且在事务执行期间，服务器不会中断事务而改去执行其他客户端的命令请求，它会将事务中的所有命令都执行完毕，然后才去处理其他客户端的命令请求。</p><p>在传统的关系式数据库中，常常用 ACID 性质来检验事务功能的可靠性和安全性。在 Redis 中，事务总是具有原子性（Atomicity）、一致性（Consistency）和隔离性（Isolation），并且当 Redis 运行在某种特定的持久化模式下时，事务也具有持久性（Durability）。</p><p>补充内容：</p><blockquote><ol><li>redis同一个事务中如果有一条命令执行失败，其后的命令仍然会被执行，没有回滚。（来自<a href="https://github.com/Snailclimb/JavaGuide/issues/452" target="_blank" rel="noopener">issue:关于Redis事务不是原子性问题</a> ）</li><li></li></ol></blockquote><h3 id="缓存雪崩和缓存穿透问题解决方案"><a href="#缓存雪崩和缓存穿透问题解决方案" class="headerlink" title="缓存雪崩和缓存穿透问题解决方案"></a>缓存雪崩和缓存穿透问题解决方案</h3><p><strong>缓存雪崩</strong> </p><p>简介：缓存同一时间大面积的失效，所以，后面的请求都会落到数据库上，造成数据库短时间内承受大量请求而崩掉。</p><p>解决办法（中华石杉老师在他的视频中提到过，视频地址在最后一个问题中有提到）：</p><ul><li>事前：尽量保证整个 redis 集群的高可用性，发现机器宕机尽快补上。选择合适的内存淘汰策略。</li><li>事中：本地ehcache缓存 + hystrix限流&amp;降级，避免MySQL崩掉</li><li>事后：利用 redis 持久化机制保存的数据尽快恢复缓存</li></ul><p><img src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-9-25/6078367.jpg" alt></p><p><strong>缓存穿透</strong> </p><p>简介：一般是黑客故意去请求缓存中不存在的数据，导致所有的请求都落到数据库上，造成数据库短时间内承受大量请求而崩掉。</p><p>解决办法： 有很多种方法可以有效地解决缓存穿透问题，最常见的则是采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被 这个bitmap拦截掉，从而避免了对底层存储系统的查询压力。另外也有一个更为简单粗暴的方法（我们采用的就是这种），如果一个查询返回的数据为空（不管是数 据不存在，还是系统故障），我们仍然把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。</p><p>参考：</p><ul><li><a href="https://blog.csdn.net/zeb_perfect/article/details/54135506" target="_blank" rel="noopener">https://blog.csdn.net/zeb_perfect/article/details/54135506</a></li></ul><h3 id="如何解决-Redis-的并发竞争-Key-问题"><a href="#如何解决-Redis-的并发竞争-Key-问题" class="headerlink" title="如何解决 Redis 的并发竞争 Key 问题"></a>如何解决 Redis 的并发竞争 Key 问题</h3><p>所谓 Redis 的并发竞争 Key 的问题也就是多个系统同时对一个 key 进行操作，但是最后执行的顺序和我们期望的顺序不同，这样也就导致了结果的不同！</p><p>推荐一种方案：分布式锁（zookeeper 和 redis 都可以实现分布式锁）。（如果不存在 Redis 的并发竞争 Key 问题，不要使用分布式锁，这样会影响性能）</p><p>基于zookeeper临时有序节点可以实现的分布式锁。大致思想为：每个客户端对某个方法加锁时，在zookeeper上的与该方法对应的指定节点的目录下，生成一个唯一的瞬时有序节点。 判断是否获取锁的方式很简单，只需要判断有序节点中序号最小的一个。 当释放锁的时候，只需将这个瞬时节点删除即可。同时，其可以避免服务宕机导致的锁无法释放，而产生的死锁问题。完成业务流程后，删除对应的子节点释放锁。</p><p>在实践中，当然是从以可靠性为主。所以首推Zookeeper。</p><p>参考：</p><ul><li><a href="https://www.jianshu.com/p/8bddd381de06" target="_blank" rel="noopener">https://www.jianshu.com/p/8bddd381de06</a></li></ul><h3 id="如何保证缓存与数据库双写时的数据一致性"><a href="#如何保证缓存与数据库双写时的数据一致性" class="headerlink" title="如何保证缓存与数据库双写时的数据一致性?"></a>如何保证缓存与数据库双写时的数据一致性?</h3><p>你只要用缓存，就可能会涉及到缓存与数据库双存储双写，你只要是双写，就一定会有数据一致性的问题，那么你如何解决一致性问题？</p><p>一般来说，就是如果你的系统不是严格要求缓存+数据库必须一致性的话，缓存可以稍微的跟数据库偶尔有不一致的情况，最好不要做这个方案，读请求和写请求串行化，串到一个内存队列里去，这样就可以保证一定不会出现不一致的情况</p><p>串行化之后，就会导致系统的吞吐量会大幅度的降低，用比正常情况下多几倍的机器去支撑线上的一个请求。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis常用Mapper语句</title>
      <link href="/posts/1/"/>
      <url>/posts/1/</url>
      
        <content type="html"><![CDATA[<h3 id="Mybatis常用Mapper语句"><a href="#Mybatis常用Mapper语句" class="headerlink" title="Mybatis常用Mapper语句"></a>Mybatis常用Mapper语句</h3><h4 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h4><pre><code class="xml">/*简单插入*/&lt;insert id=&quot;insertOne&quot; parameterType=&quot;Person&quot;&gt;    insert into person (id, name, age) values(#{id},#{name},#{age});&lt;/insert&gt;/* 插入并返回对象的主键（数据库序列） */&lt;insert id=&quot;insertOne&quot; parameterType=&quot;Person&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;&gt;    insert into person (name, age) VALUES(#{name}, #{age});&lt;/insert&gt;</code></pre><h4 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h4><pre><code class="xml">/* 简单更新 */&lt;update id=&quot;updateName&quot;&gt;     update person set name = #{name} where id = #{id};&lt;/update&gt;/* 更新值并返回 */&lt;select id=&quot;updateAge&quot; parameterType=&quot;Person&quot;&gt;    update person set age = age + #{age} where id = #{id} returning age;&lt;/select&gt;</code></pre><h4 id="插入或更新"><a href="#插入或更新" class="headerlink" title="插入或更新"></a>插入或更新</h4><ol><li>方式一<pre><code>&lt;insert id=&quot;addCount&quot; parameterType=&quot;CountRecord&quot;&gt;/*如果有记录，则更新；无记录，则noting*/updatecount_recordset&quot;count&quot; = &quot;count&quot;+1wheretype_id = #{typeId}anduser_id = #{userId};/*如果有记录，则noting；无记录，则插入*/insert intocount_record(type_id, user_id, &quot;count&quot;)select  #{typeId}, #{userId}, 1where not exists    (select        *     from        count     where        type_id = #{typeId}     and        user_id = #{userId});&lt;/insert&gt;</code></pre></li><li>方式2<pre><code class="xml">/* 利用 PostgreSQL 的 conflic 特性 */&lt;insert id=&quot;addCount&quot; parameterType=&quot;CountRecord&quot;&gt;insert intocount_record(type_id, user_id, &quot;count&quot;)VALUES(#{typeId}, #{userId}, #{count})onconflict(type_id,user_id)do update set&quot;count&quot; = count_record.&quot;count&quot; + 1&lt;/insert&gt;</code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> java技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构</title>
      <link href="/posts/1106/"/>
      <url>/posts/1106/</url>
      
        <content type="html"><![CDATA[<p>下面只是简单地总结，给了一些参考文章，后面会对这部分内容进行重构。</p><!-- MarkdownTOC --><!-- - [Queue](#queue)    - [什么是队列](#什么是队列)    - [队列的种类](#队列的种类)    - [Java 集合框架中的队列 Queue](#java-集合框架中的队列-queue)    - [推荐文章](#推荐文章)- [Set](#set)    - [什么是 Set](#什么是-set)    - [补充：有序集合与无序集合说明](#补充：有序集合与无序集合说明)    - [HashSet 和 TreeSet 底层数据结构](#hashset-和-treeset-底层数据结构)    - [推荐文章](#推荐文章-1)- [List](#list)    - [什么是List](#什么是list)    - [List的常见实现类](#list的常见实现类)    - [ArrayList 和 LinkedList 源码学习](#arraylist-和-linkedlist-源码学习)    - [推荐阅读](#推荐阅读)- [Map](#map)- [树](#树) --><!-- /MarkdownTOC --><p>@[toc]</p><h2 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h2><h3 id="什么是队列"><a href="#什么是队列" class="headerlink" title="什么是队列"></a>什么是队列</h3><p>队列是数据结构中比较重要的一种类型，它支持 FIFO，尾部添加、头部删除（先进队列的元素先出队列），跟我们生活中的排队类似。</p><h3 id="队列的种类"><a href="#队列的种类" class="headerlink" title="队列的种类"></a>队列的种类</h3><ul><li><strong>单队列</strong>（单队列就是常见的队列, 每次添加元素时，都是添加到队尾，存在“假溢出”的问题也就是明明有位置却不能添加的情况）</li><li><strong>循环队列</strong>（避免了“假溢出”的问题）</li></ul><h3 id="Java-集合框架中的队列-Queue"><a href="#Java-集合框架中的队列-Queue" class="headerlink" title="Java 集合框架中的队列 Queue"></a>Java 集合框架中的队列 Queue</h3><p>Java 集合中的 Queue 继承自 Collection 接口 ，Deque, LinkedList, PriorityQueue, BlockingQueue 等类都实现了它。<br>Queue 用来存放 等待处理元素 的集合，这种场景一般用于缓冲、并发访问。<br>除了继承 Collection 接口的一些方法，Queue 还添加了额外的 添加、删除、查询操作。</p><h3 id="推荐文章"><a href="#推荐文章" class="headerlink" title="推荐文章"></a>推荐文章</h3><ul><li><a href="https://blog.csdn.net/u011240877/article/details/52860924" target="_blank" rel="noopener">Java 集合深入理解（9）：Queue 队列</a></li></ul><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><h3 id="什么是-Set"><a href="#什么是-Set" class="headerlink" title="什么是 Set"></a>什么是 Set</h3><p>Set 继承于 Collection 接口，是一个不允许出现重复元素，并且无序的集合，主要 HashSet 和 TreeSet 两大实现类。</p><p>在判断重复元素的时候，Set 集合会调用 hashCode()和 equal()方法来实现。</p><h3 id="补充：有序集合与无序集合说明"><a href="#补充：有序集合与无序集合说明" class="headerlink" title="补充：有序集合与无序集合说明"></a>补充：有序集合与无序集合说明</h3><ul><li>有序集合：集合里的元素可以根据 key 或 index 访问 (List、Map)</li><li>无序集合：集合里的元素只能遍历。（Set）</li></ul><h3 id="HashSet-和-TreeSet-底层数据结构"><a href="#HashSet-和-TreeSet-底层数据结构" class="headerlink" title="HashSet 和 TreeSet 底层数据结构"></a>HashSet 和 TreeSet 底层数据结构</h3><p><strong>HashSet</strong> 是哈希表结构，主要利用 HashMap 的 key 来存储元素，计算插入元素的 hashCode 来获取元素在集合中的位置；</p><p><strong>TreeSet</strong> 是红黑树结构，每一个元素都是树中的一个节点，插入的元素都会进行排序；</p><h3 id="推荐文章-1"><a href="#推荐文章-1" class="headerlink" title="推荐文章"></a>推荐文章</h3><ul><li><a href="https://www.jianshu.com/p/b48c47a42916" target="_blank" rel="noopener">Java集合–Set(基础)</a></li></ul><h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><h3 id="什么是List"><a href="#什么是List" class="headerlink" title="什么是List"></a>什么是List</h3><p>在 List 中，用户可以精确控制列表中每个元素的插入位置，另外用户可以通过整数索引（列表中的位置）访问元素，并搜索列表中的元素。 与 Set 不同，List 通常允许重复的元素。 另外 List 是有序集合而 Set 是无序集合。</p><h3 id="List的常见实现类"><a href="#List的常见实现类" class="headerlink" title="List的常见实现类"></a>List的常见实现类</h3><p><strong>ArrayList</strong> 是一个数组队列，相当于动态数组。它由数组实现，随机访问效率高，随机插入、随机删除效率低。</p><p><strong>LinkedList</strong> 是一个双向链表。它也可以被当作堆栈、队列或双端队列进行操作。LinkedList随机访问效率低，但随机插入、随机删除效率高。</p><p><strong>Vector</strong> 是矢量队列，和ArrayList一样，它也是一个动态数组，由数组实现。但是ArrayList是非线程安全的，而Vector是线程安全的。</p><p><strong>Stack</strong> 是栈，它继承于Vector。它的特性是：先进后出(FILO, First In Last Out)。相关阅读：<a href="https://blog.csdn.net/javazejian/article/details/53362993" target="_blank" rel="noopener">java数据结构与算法之栈（Stack）设计与实现</a></p><h3 id="ArrayList-和-LinkedList-源码学习"><a href="#ArrayList-和-LinkedList-源码学习" class="headerlink" title="ArrayList 和 LinkedList 源码学习"></a>ArrayList 和 LinkedList 源码学习</h3><ul><li><a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/collection/ArrayList.md" target="_blank" rel="noopener">ArrayList 源码学习</a>    </li><li><a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/collection/LinkedList.md" target="_blank" rel="noopener">LinkedList 源码学习</a>   </li></ul><h3 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h3><ul><li><a href="https://blog.csdn.net/javazejian/article/details/52953190" target="_blank" rel="noopener">java 数据结构与算法之顺序表与链表深入分析</a></li></ul><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><ul><li><a href="https://juejin.im/post/5ab0568b5188255580020e56" target="_blank" rel="noopener">集合框架源码学习之 HashMap(JDK1.8)</a></li><li><a href="https://link.juejin.im/?target=http%3A%2F%2Fwww.cnblogs.com%2Fchengxiao%2Fp%2F6842045.html" target="_blank" rel="noopener">ConcurrentHashMap 实现原理及源码分析</a></li></ul><h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><ul><li><h3 id="1-二叉树"><a href="#1-二叉树" class="headerlink" title="1 二叉树"></a>1 二叉树</h3><p> <a href="https://baike.baidu.com/item/%E4%BA%8C%E5%8F%89%E6%A0%91" target="_blank" rel="noopener">二叉树</a>（百度百科）</p><p>(1)<a href="https://baike.baidu.com/item/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91" target="_blank" rel="noopener">完全二叉树</a>——若设二叉树的高度为h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第h层有叶子结点，并且叶子结点都是从左到右依次排布，这就是完全二叉树。</p><p>(2)<a href="https://baike.baidu.com/item/%E6%BB%A1%E4%BA%8C%E5%8F%89%E6%A0%91" target="_blank" rel="noopener">满二叉树</a>——除了叶结点外每一个结点都有左右子叶且叶子结点都处在最底层的二叉树。</p><p>(3)<a href="https://baike.baidu.com/item/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/10421057" target="_blank" rel="noopener">平衡二叉树</a>——平衡二叉树又被称为AVL树（区别于AVL算法），它是一棵二叉排序树，且具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。 </p></li><li><h3 id="2-完全二叉树"><a href="#2-完全二叉树" class="headerlink" title="2 完全二叉树"></a>2 完全二叉树</h3><p><a href="https://baike.baidu.com/item/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91" target="_blank" rel="noopener">完全二叉树</a>（百度百科）</p><p>完全二叉树：叶节点只能出现在最下层和次下层，并且最下面一层的结点都集中在该层最左边的若干位置的二叉树。</p></li><li><h3 id="3-满二叉树"><a href="#3-满二叉树" class="headerlink" title="3 满二叉树"></a>3 满二叉树</h3><p> <a href="https://baike.baidu.com/item/%E6%BB%A1%E4%BA%8C%E5%8F%89%E6%A0%91" target="_blank" rel="noopener">满二叉树</a>（百度百科，国内外的定义不同）</p><p> 国内教程定义：一个二叉树，如果每一个层的结点数都达到最大值，则这个二叉树就是满二叉树。也就是说，如果一个二叉树的层数为K，且结点总数是(2^k) -1 ，则它就是满二叉树。</p></li><li><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p> <a href="https://blog.csdn.net/qq_33186366/article/details/51876191" target="_blank" rel="noopener">数据结构之堆的定义</a></p><p>堆是具有以下性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆。</p></li><li><h3 id="4-二叉查找树（BST）"><a href="#4-二叉查找树（BST）" class="headerlink" title="4 二叉查找树（BST）"></a>4 二叉查找树（BST）</h3><p><a href="http://www.cnblogs.com/yangecnu/p/Introduce-Binary-Search-Tree.html" target="_blank" rel="noopener">浅谈算法和数据结构: 七 二叉查找树</a></p><p> 二叉查找树的特点：</p><ol><li>若任意节点的左子树不空，则左子树上所有结点的     值均小于它的根结点的值；</li><li>若任意节点的右子树不空，则右子树上所有结点的值均大于它的根结点的值；</li><li>任意节点的左、右子树也分别为二叉查找树；</li><li>没有键值相等的节点（no duplicate nodes）。</li></ol></li><li><h3 id="5-平衡二叉树（Self-balancing-binary-search-tree）"><a href="#5-平衡二叉树（Self-balancing-binary-search-tree）" class="headerlink" title="5 平衡二叉树（Self-balancing binary search tree）"></a>5 平衡二叉树（Self-balancing binary search tree）</h3><p><a href="https://baike.baidu.com/item/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91" target="_blank" rel="noopener"> 平衡二叉树</a>（百度百科，平衡二叉树的常用实现方法有红黑树、AVL、替罪羊树、Treap、伸展树等）</p></li><li><h3 id="6-红黑树"><a href="#6-红黑树" class="headerlink" title="6 红黑树"></a>6 红黑树</h3><ul><li><p>红黑树特点:</p><ol><li>每个节点非红即黑；</li><li>根节点总是黑色的；</li><li>每个叶子节点都是黑色的空节点（NIL节点）；</li><li>如果节点是红色的，则它的子节点必须是黑色的（反之不一定）；</li><li>从根节点到叶节点或空子节点的每条路径，必须包含相同数目的黑色节点（即相同的黑色高度）。</li></ol></li><li><p>红黑树的应用：</p><p>  TreeMap、TreeSet以及JDK1.8之后的HashMap底层都用到了红黑树。</p></li><li><p>为什么要用红黑树</p><p>简单来说红黑树就是为了解决二叉查找树的缺陷，因为二叉查找树在某些情况下会退化成一个线性结构。详细了解可以查看 <a href="https://juejin.im/post/5a27c6946fb9a04509096248#comment" target="_blank" rel="noopener">漫画：什么是红黑树？</a>（也介绍到了二叉查找树，非常推荐）</p></li><li><p>推荐文章： </p><ul><li><a href="https://juejin.im/post/5a27c6946fb9a04509096248#comment" target="_blank" rel="noopener">漫画：什么是红黑树？</a>（也介绍到了二叉查找树，非常推荐）</li><li><a href="http://dandanlove.com/2018/03/18/red-black-tree/" target="_blank" rel="noopener">寻找红黑树的操作手册</a>（文章排版以及思路真的不错）</li><li><a href="https://zhuanlan.zhihu.com/p/24367771" target="_blank" rel="noopener">红黑树深入剖析及Java实现</a>（美团点评技术团队）    </li></ul></li></ul></li><li><h3 id="7-B-，B-，B-树"><a href="#7-B-，B-，B-树" class="headerlink" title="7 B-，B+，B*树"></a>7 B-，B+，B*树</h3><p> <a href="https://yq.aliyun.com/articles/38345" target="_blank" rel="noopener">二叉树学习笔记之B树、B+树、B*树 </a></p><p> <a href="https://blog.csdn.net/aqzwss/article/details/53074186" target="_blank" rel="noopener">《B-树，B+树，B*树详解》</a></p><p> <a href="https://blog.csdn.net/bigtree_3721/article/details/73632405" target="_blank" rel="noopener">《B-树，B+树与B*树的优缺点比较》</a></p><p>B-树（或B树）是一种平衡的多路查找（又称排序）树，在文件系统中有所应用。主要用作文件的索引。其中的B就表示平衡(Balance) </p><ol><li>B+ 树的叶子节点链表结构相比于 B- 树便于扫库，和范围检索。</li><li>B+树支持range-query（区间查询）非常方便，而B树不支持。这是数据库选用B+树的最主要原因。</li><li>B*树 是B+树的变体，B*树分配新结点的概率比B+树要低，空间使用率更高；</li></ol></li><li><h3 id="8-LSM-树"><a href="#8-LSM-树" class="headerlink" title="8 LSM 树"></a>8 LSM 树</h3><p><a href="https://blog.csdn.net/dbanote/article/details/8897599" target="_blank" rel="noopener">[HBase] LSM树 VS B+树</a></p><p>B+树最大的性能问题是会产生大量的随机IO</p><p>为了克服B+树的弱点，HBase引入了LSM树的概念，即Log-Structured Merge-Trees。</p><p><a href="http://www.cnblogs.com/yanghuahui/p/3483754.html" target="_blank" rel="noopener">LSM树由来、设计思想以及应用到HBase的索引</a></p></li></ul><h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><h2 id="BFS及DFS"><a href="#BFS及DFS" class="headerlink" title="BFS及DFS"></a>BFS及DFS</h2><ul><li><a href="https://blog.csdn.net/Gene1994/article/details/85097507" target="_blank" rel="noopener">《使用BFS及DFS遍历树和图的思路及实现》</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> java技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
